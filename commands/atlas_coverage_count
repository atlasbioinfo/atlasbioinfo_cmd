#!/Users/hyu/Intel_miniforge3/envs/PYSAM/bin/python
# -*- coding: utf-8 -*-

import os,re,sys,pysam,time
import numpy as np
import argparse

def checkread(read): #reverse strand
    # if not read.is_paired:
    if (read.is_reverse):
        return False
    # if read.is_read1 and read.mate_is_reverse:
    #     return True
    # if read.is_read2 and read.mate_is_reverse:
    #     return True
    
    return True

def combine4Arr(arrs):
    cArr=[]
    for i in range(len(arrs[0])):
        cArr.append(str(arrs[0][i]+arrs[1][i]+arrs[2][i]+arrs[3][i]))
    return ",".join(cArr)

def main(input_file, output, reads_all):
    beg=time.time()
    bamfile=pysam.AlignmentFile(input_file, "rb")

    discardReverse=0
    calculate_reads=0
    # count=0
    # limit=100000
    with open(output,"w") as out:
        for i in range(bamfile.nreferences):
            tname=bamfile.get_reference_name(i)
            tlen=bamfile.get_reference_length(tname)
            if (bamfile.count(tname)==0):
                continue
            genePos=[0 for i in range(int(tlen))]
            geneCov=np.array([0 for i in range(int(tlen))])
            for read in bamfile.fetch(tname):
                if (read.is_unmapped):
                    continue
                calculate_reads+=1
                if (reads_all):
                    genePos[read.reference_start]+=1
                    geneCov[read.reference_start:read.reference_end+1]+=1
                    continue
                if (checkread(read)):
                    # count+=1
                    # if (count>limit):
                    #     break
                    discardReverse+=1
                    genePos[read.reference_start]+=1
                    geneCov[read.reference_start:read.reference_end+1]+=1

            genePos=[str(i) for i in genePos]
            geneCov=[str(i) for i in geneCov]

            out.write("\t".join([
                tname,
                ",".join(genePos),
                ",".join(geneCov)
            ])+"\n")
    # print(count)
    if (reads_all):
        print("Total reads: "+str(calculate_reads))
    else:
        print("Total reads: "+str(calculate_reads))
        print("Calculated (discard reverse reads): "+str(discardReverse))
    
    print("Time elapsed: "+str(time.time()-beg)+"s")

if __name__=="__main__":

    logo='''      
          _   _             ____  _       _        __      
     /\  | | | |           |  _ \(_)     (_)      / _|     
    /  \ | |_| | __ _ ___  | |_) |_  ___  _ _ __ | |_ ___  
   / /\ \| __| |/ _` / __| |  _ <| |/ _ \| | '_ \|  _/ _ \ 
  / ____ \ |_| | (_| \__ \ | |_) | | (_) | | | | | || (_) |
 /_/    \_\__|_|\__,_|___/ |____/|_|\___/|_|_| |_|_| \___/  

        `-:-.   ,-;"`-:-.   ,-;"`-:-.   ,-;"`-:-.   ,-;"
        `=`,'=/     `=`,'=/     `=`,'=/     `=`,'=/
            y==/        y==/        y==/        y==/
        ,=,-<=`.    ,=,-<=`.    ,=,-<=`.    ,=,-<=`.
        ,-'-'   `-=_,-'-'   `-=_,-'-'   `-=_,-'-'   `-=_
                
    '''


    description_text = '''{} 
"atlas_coverage_count" processes a "indexed BAM" file to calculate and output the coverage and position counts for each reference, discarding reverse strand reads, and saves the statistics in a ".count" appended file, with a tab-separated format of Reference Name, position counts, and cumulative coverages. '''.format(logo)

    parser = argparse.ArgumentParser(description=description_text, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('input_bam', type=str, help='Path to the input indexed BAM file.')
    parser.add_argument('-o', '--output', type=str, default=None, help='output file name, default is input_file.AtlasCovRT')
    parser.add_argument('-a', '--all', type=bool, default=False, help='output all reads, include the antisense stranded reads, default is False')
    
    args = parser.parse_args()
    if args.output is None:
        args.output = args.input_bam + ".AtlasCovRT"
    main(args.input_bam, args.output, args.all)